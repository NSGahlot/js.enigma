---
title: 2D Matrix Graph Algorithms
description: A comprehensive guide to 2D DFS, 2D BFS, and 2D Dijkstra algorithms with code examples in JavaScript.
---

# 2D Graph Algorithms Tutorial

## Introduction

In many problems involving grids or 2D matrices, algorithms designed for 2D graphs become crucial. These algorithms help in navigating and solving various tasks in grid-based problems. This tutorial covers three key algorithms used in 2D grids:

- **2D Depth-First Search (DFS)**
- **2D Breadth-First Search (BFS)**
- **2D Dijkstra's Algorithm**

## 2D Depth-First Search (DFS)

### Overview

DFS explores as far as possible along each branch before backtracking. In a 2D grid, DFS can be used to traverse and solve problems like connected components or island counting.

### Implementation

Hereâ€™s a JavaScript implementation of 2D DFS:

```JavaScript
function dfs(grid, row, col, visited) {
  // Check boundaries and if the cell is already visited
  if (
    row < 0 || row >= grid.length ||
    col < 0 || col >= grid[0].length ||
    visited[row][col]
  ) {
    return;
  }

  // Mark the cell as visited
  visited[row][col] = true;

  // Print the current cell's value
  console.log(grid[row][col]);

  // Define the directions for traversal: right, down, left, up
  const directions = [
    [0, 1],    // right
    [1, 0],    // down
    [0, -1],   // left
    [-1, 0],   // up
    [1, 1],    // down-right (diagonal)
    [1, -1],   // down-left (diagonal)
    [-1, 1],   // up-right (diagonal)
    [-1, -1]   // up-left (diagonal)
  ];

  // Explore all neighbors
  for (let [dr, dc] of directions) {
    dfs(grid, row + dr, col + dc, visited);
  }
}

// Example usage:
const grid = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];

// Create a visited matrix initialized to false
const visited = Array.from({ length: grid.length }, () => Array(grid[0].length).fill(false));

// Start DFS from cell (0, 0)
dfs(grid, 0, 0, visited);

```

## 2D Breadth-First Search (BFS)

```JavaScript
function bfs(grid, startRow, startCol) {
  const rows = grid.length;
  const cols = grid[0].length;

  // Direction vectors for moving right, down, left, and up
  const directions = [
    [0, 1],   // right
    [1, 0],   // down
    [0, -1],  // left
    [-1, 0]   // up
  ];

  // Create a visited matrix initialized to false
  const visited = Array.from({ length: rows }, () => Array(cols).fill(false));

  // Initialize the queue with the starting cell
  const queue = [[startRow, startCol]];
  visited[startRow][startCol] = true;

  while (queue.length > 0) {
    // Dequeue the front cell
    const [row, col] = queue.shift();

    // Print the current cell's value
    console.log(grid[row][col]);

    // Explore all neighbors
    for (let [dr, dc] of directions) {
      const newRow = row + dr;
      const newCol = col + dc;

      // Check if the new position is within bounds and not visited
      if (
        newRow >= 0 && newRow < rows &&
        newCol >= 0 && newCol < cols &&
        !visited[newRow][newCol]
      ) {
        // Mark the new cell as visited and enqueue it
        visited[newRow][newCol] = true;
        queue.push([newRow, newCol]);
      }
    }
  }
}
```

## 2D Dijkstra (Shortest Path)

```JavaScript
function dijkstra(grid, start, end) {
  const rows = grid.length;
  const cols = grid[0].length;
  const distances = Array.from({ length: rows }, () => Array(cols).fill(Infinity));
  const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]]; // Right, Down, Left, Up
  const heap = new MinHeap();
  const [startRow, startCol] = start;
  const [endRow, endCol] = end;

  distances[startRow][startCol] = 0;
  heap.push([0, startRow, startCol]); //startDistance, row, col

  while (heap.heap.length > 0) {
    const [currentDist, row, col] = heap.pop();

    if (row === endRow && col === endCol) {
      return currentDist;
    }

    for (const [dr, dc] of directions) {
      const newRow = row + dr;
      const newCol = col + dc;

      if (
        newRow >= 0 &&
        newRow < rows &&
        newCol >= 0 &&
        newCol < cols
      ) {
        const newDist = currentDist + grid[newRow][newCol];
        if (newDist < distances[newRow][newCol]) {
          distances[newRow][newCol] = newDist;
          heap.push([newDist, newRow, newCol]);
        }
      }
    }
  }

  return -1; // If no path is found
}
```